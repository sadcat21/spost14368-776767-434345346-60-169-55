import { useState, useCallback } from 'react';
import { toast } from 'sonner';
import { supabase } from "@/integrations/supabase/client";
import { createGeminiKeyManager } from '@/utils/apiKeyRotationManager';
import { useGeminiImageAnalysis } from './useGeminiImageAnalysis';

interface ImageGenerationParams {
  prompt: string;
  model?: string;
  temperature?: number;
  maxOutputTokens?: number;
  apiKey?: string;
}

interface ImageEditingParams {
  prompt: string;
  imageFile: File;
  model?: string;
  temperature?: number;
  maxOutputTokens?: number;
  apiKey?: string;
}

interface GeneratedImageResult {
  imageUrl: string;
  imageData: string; // base64
  description?: string;
  mimeType: string;
}

export const useGeminiImageGeneration = () => {
  const [isGenerating, setIsGenerating] = useState(false);
  const [generatedImage, setGeneratedImage] = useState<GeneratedImageResult | null>(null);
  const [error, setError] = useState<string | null>(null);
  
  // Ø§Ø³ØªØ®Ø¯Ø§Ù… hook ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØµÙˆØ± Ù„ØªÙˆÙ„ÙŠØ¯ ÙˆØµÙ Ø°ÙƒÙŠ
  const { generateImageDescription } = useGeminiImageAnalysis();

  // ØªØ­ÙˆÙŠÙ„ File Ø¥Ù„Ù‰ base64
  const fileToBase64 = (file: File): Promise<string> => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => {
        const base64 = reader.result as string;
        // Ø¥Ø²Ø§Ù„Ø© data:image/...;base64, Ù…Ù† Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
        const base64Data = base64.split(',')[1];
        resolve(base64Data);
      };
      reader.onerror = reject;
      reader.readAsDataURL(file);
    });
  };

  // ØªÙˆÙ„ÙŠØ¯ ØµÙˆØ±Ø© Ù…Ù† Ø§Ù„Ù†Øµ
  const generateImage = useCallback(async (params: ImageGenerationParams): Promise<GeneratedImageResult | null> => {
    setIsGenerating(true);
    setError(null);
    
    try {
      console.log('ğŸ¨ Starting image generation with Gemini...');
      
      // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¯ÙŠØ± Ø¯ÙˆØ±Ø§Ù† Ø§Ù„Ù…ÙØ§ØªÙŠØ­
      const keyManager = createGeminiKeyManager();
      console.log('ğŸ”‘ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù†Ø¸Ø§Ù… Ø¯ÙˆØ±Ø§Ù† Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ');
      
      const requestBody = {
        contents: [
          {
            parts: [
              {
                text: `Generate a high-quality, detailed image: ${params.prompt}. Professional composition, high resolution, vibrant colors.`
              }
            ]
          }
        ],
        generationConfig: {
          temperature: params.temperature || 0.7,
          maxOutputTokens: params.maxOutputTokens || 2048,
          topP: 0.95,
          topK: 40,
          responseModalities: ["TEXT", "IMAGE"]
        }
      };

      // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ø¯ÙŠØ± Ø¯ÙˆØ±Ø§Ù† Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ù„ØªÙ†ÙÙŠØ° Ø§Ù„Ø·Ù„Ø¨
      const response = await keyManager.makeRequest({
        url: `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent`,
        apiKeyParam: 'key',
        options: {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(requestBody),
        }
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error('Gemini API error:', errorText);
        throw new Error(`Ø®Ø·Ø£ Ù…Ù† Gemini API: ${response.status} - ${errorText}`);
      }

      const apiData = await response.json();
      console.log('Gemini API response received');

      // Find the image part in the response
      const candidate = apiData.candidates?.[0];
      if (!candidate || !candidate.content || !candidate.content.parts) {
        throw new Error('No content generated by Gemini API');
      }

      let extractedImageData = null;
      let textResponse = null;

      // Extract image and text from response parts
      for (const part of candidate.content.parts) {
        if (part.inlineData && part.inlineData.data) {
          extractedImageData = part.inlineData.data;
        } else if (part.text) {
          textResponse = part.text;
        }
      }

      if (!extractedImageData) {
        throw new Error('No image generated by Gemini API');
      }

      // Convert base64 image to a data URL
      const resultMimeType = candidate.content.parts.find(p => p.inlineData)?.inlineData?.mimeType || 'image/png';
      const resultImageUrl = `data:${resultMimeType};base64,${extractedImageData}`;

      // ØªÙˆÙ„ÙŠØ¯ ÙˆØµÙ Ø°ÙƒÙŠ Ù„Ù„ØµÙˆØ±Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Gemini Vision
      console.log('ğŸ‘ï¸ ØªÙˆÙ„ÙŠØ¯ ÙˆØµÙ Ø°ÙƒÙŠ Ù„Ù„ØµÙˆØ±Ø© Ø§Ù„Ù…ÙˆÙ„Ø¯Ø©...');
      const intelligentDescription = await generateImageDescription(extractedImageData, resultMimeType);

      const finalResult: GeneratedImageResult = {
        imageUrl: resultImageUrl,
        imageData: extractedImageData,
        description: intelligentDescription || textResponse || 'ØµÙˆØ±Ø© Ù…ÙˆÙ„Ø¯Ø© Ø¨ÙˆØ§Ø³Ø·Ø© Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ',
        mimeType: resultMimeType
      };

      setGeneratedImage(finalResult);
      console.log('âœ… ØªÙ… ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØ±Ø© Ø¨Ù†Ø¬Ø§Ø­ Ù…Ø¹ ÙˆØµÙ Ø°ÙƒÙŠ');
      toast.success('ØªÙ… ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØ±Ø© Ù…Ø¹ ÙˆØµÙ Ø°ÙƒÙŠ Ø¨Ù†Ø¬Ø§Ø­!');
      return finalResult;

    } catch (error) {
      console.error('âŒ Ø®Ø·Ø£ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØ±Ø©:', error);
      const errorMessage = error instanceof Error ? error.message : 'Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØ±Ø©';
      setError(errorMessage);
      toast.error(errorMessage);
      return null;
    } finally {
      setIsGenerating(false);
    }
  }, []);

  // ØªØ¹Ø¯ÙŠÙ„ ØµÙˆØ±Ø© Ù…ÙˆØ¬ÙˆØ¯Ø©
  const editImage = useCallback(async (params: ImageEditingParams): Promise<GeneratedImageResult | null> => {
    setIsGenerating(true);
    setError(null);
    
    try {
      console.log('ğŸ–¼ï¸ Starting image editing with Gemini...');
      
      // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¯ÙŠØ± Ø¯ÙˆØ±Ø§Ù† Ø§Ù„Ù…ÙØ§ØªÙŠØ­
      const keyManager = createGeminiKeyManager();
      console.log('ğŸ”‘ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù†Ø¸Ø§Ù… Ø¯ÙˆØ±Ø§Ù† Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ØµÙˆØ±');
      
      // ØªØ­ÙˆÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© Ø¥Ù„Ù‰ base64
      const base64Image = await fileToBase64(params.imageFile);
      
      const requestBody = {
        contents: [
          {
            parts: [
              {
                text: `Edit this image: ${params.prompt}`
              },
              {
                inlineData: {
                  mimeType: params.imageFile.type,
                  data: base64Image
                }
              }
            ]
          }
        ],
        generationConfig: {
          temperature: params.temperature || 0.8,
          maxOutputTokens: params.maxOutputTokens || 1000,
          topP: 0.95,
          topK: 40,
          responseModalities: ["TEXT", "IMAGE"]
        }
      };

      // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ø¯ÙŠØ± Ø¯ÙˆØ±Ø§Ù† Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ù„ØªÙ†ÙÙŠØ° Ø§Ù„Ø·Ù„Ø¨
      const response = await keyManager.makeRequest({
        url: `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent`,
        apiKeyParam: 'key',
        options: {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(requestBody),
        }
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error('Gemini API error:', errorText);
        throw new Error(`Ø®Ø·Ø£ Ù…Ù† Gemini API: ${response.status} - ${errorText}`);
      }

      const apiData = await response.json();
      console.log('Gemini API response received');

      // Find the image part in the response
      const candidate = apiData.candidates?.[0];
      if (!candidate || !candidate.content || !candidate.content.parts) {
        throw new Error('No content generated by Gemini API');
      }

      let extractedImageData = null;
      let textResponse = null;

      // Extract image and text from response parts
      for (const part of candidate.content.parts) {
        if (part.inlineData && part.inlineData.data) {
          extractedImageData = part.inlineData.data;
        } else if (part.text) {
          textResponse = part.text;
        }
      }

      if (!extractedImageData) {
        throw new Error('No image generated by Gemini API');
      }

      // Convert base64 image to a data URL
      const resultMimeType = candidate.content.parts.find(p => p.inlineData)?.inlineData?.mimeType || 'image/png';
      const resultImageUrl = `data:${resultMimeType};base64,${extractedImageData}`;

      // ØªÙˆÙ„ÙŠØ¯ ÙˆØµÙ Ø°ÙƒÙŠ Ù„Ù„ØµÙˆØ±Ø© Ø§Ù„Ù…Ø¹Ø¯Ù„Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Gemini Vision
      console.log('ğŸ‘ï¸ ØªÙˆÙ„ÙŠØ¯ ÙˆØµÙ Ø°ÙƒÙŠ Ù„Ù„ØµÙˆØ±Ø© Ø§Ù„Ù…Ø¹Ø¯Ù„Ø©...');
      const intelligentDescription = await generateImageDescription(extractedImageData, resultMimeType);

      const finalResult: GeneratedImageResult = {
        imageUrl: resultImageUrl,
        imageData: extractedImageData,
        description: intelligentDescription || textResponse || 'ØµÙˆØ±Ø© Ù…Ø¹Ø¯Ù„Ø© Ø¨ÙˆØ§Ø³Ø·Ø© Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ',
        mimeType: resultMimeType
      };

      setGeneratedImage(finalResult);
      console.log('âœ… ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© Ø¨Ù†Ø¬Ø§Ø­ Ù…Ø¹ ÙˆØµÙ Ø°ÙƒÙŠ');
      toast.success('ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© Ù…Ø¹ ÙˆØµÙ Ø°ÙƒÙŠ Ø¨Ù†Ø¬Ø§Ø­!');
      return finalResult;

    } catch (error) {
      console.error('âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©:', error);
      const errorMessage = error instanceof Error ? error.message : 'Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©';
      setError(errorMessage);
      toast.error(errorMessage);
      return null;
    } finally {
      setIsGenerating(false);
    }
  }, []);

  const resetImage = useCallback(() => {
    if (generatedImage?.imageUrl) {
      URL.revokeObjectURL(generatedImage.imageUrl);
    }
    setGeneratedImage(null);
    setError(null);
  }, [generatedImage]);

  return {
    generateImage,
    editImage,
    resetImage,
    isGenerating,
    generatedImage,
    error
  };
};