// Facebook Webhook v2 - Advanced AI-powered comment and message handler
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";

// ====== Configuration ======
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

const PAGE_ACCESS_TOKEN = Deno.env.get('PAGE_ACCESS_TOKEN');
const GEMINI_API_KEY = Deno.env.get('GEMINI_API_KEY');
const VERIFY_TOKEN = Deno.env.get('FACEBOOK_WEBHOOK_VERIFY_TOKEN') || 'facebook_webhook_verify_token_123';

const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;
const FACEBOOK_GRAPH_URL = 'https://graph.facebook.com/v19.0';

// ====== Utility Functions ======
async function callGemini(prompt: string, imageData?: { mimeType: string; data: string }): Promise<string> {
  try {
    const parts: any[] = [{ text: prompt }];
    if (imageData) {
      parts.push({
        inline_data: {
          mime_type: imageData.mimeType,
          data: imageData.data
        }
      });
    }

    const response = await fetch(GEMINI_API_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        contents: [{ parts }],
        generationConfig: {
          temperature: 0.7,
          topK: 40,
          topP: 0.95,
          maxOutputTokens: 300,
        }
      })
    });

    const data = await response.json();
    return data.candidates?.[0]?.content?.parts?.[0]?.text || "";
  } catch (error) {
    console.error('Gemini API error:', error);
    return "";
  }
}

function isImageQuestion(text: string): boolean {
  const imageKeywords = [
    'ÿµŸàÿ±ÿ©', 'ÿµŸàÿ±Ÿá', 'ÿßŸÑÿµŸàÿ±ÿ©', 'ŸÅŸä ÿßŸÑÿµŸàÿ±ÿ©', 'ÿ®ÿßŸÑÿµŸàÿ±ÿ©',
    'ŸÑŸàŸÜ', 'ÿ£ŸÑŸàÿßŸÜ', 'ÿßŸÑŸÑŸàŸÜ', 'ÿßŸÑÿ£ŸÑŸàÿßŸÜ',
    'ŸÖŸÉÿ™Ÿàÿ®', 'ŸÜÿµ', 'ŸÉŸÑŸÖÿ©', 'ŸÉŸÑŸÖÿßÿ™', 'ÿπÿ®ÿßÿ±ÿ©',
    'ÿ¥ŸÉŸÑ', 'ÿ£ÿ¥ŸÉÿßŸÑ', 'Ÿäÿ∏Ÿáÿ±', 'ŸÖŸàÿ¨ŸàÿØ', 'ÿ£ÿ±Ÿâ', 'ÿ™ÿ±Ÿâ',
    'ŸÖÿßÿ∞ÿß', 'Ÿàÿ¥', 'ÿßŸäÿ¥', 'ÿ¥Ÿà', 'ÿ£ŸäŸá', 'ÿßŸÇÿ±ÿ£', 'ÿßŸÇÿ±ÿß'
  ];
  
  const hasImageKeyword = imageKeywords.some(keyword => 
    text.toLowerCase().includes(keyword)
  );
  
  const isQuestion = text.includes("ÿü") || text.startsWith("ŸÖÿß") || 
                   text.startsWith("ŸÖÿßÿ∞ÿß") || text.startsWith("ÿ£ŸäŸÜ");
  
  return hasImageKeyword && isQuestion;
}

async function isOffensiveContent(text: string): Promise<boolean> {
  const prompt = `
ŸÇŸÖ ÿ®ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÜÿµ ÿßŸÑÿ™ÿßŸÑŸä Ÿàÿ≠ÿØÿØ ÿ•ÿ∞ÿß ŸÉÿßŸÜ Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ:
- ÿ•ÿ≥ÿßÿ°ÿ© ÿ£Ÿà ÿ≥ÿ®
- ÿßÿ™ŸáÿßŸÖ ÿ®ÿßŸÑÿÆÿØÿßÿπ ÿ£Ÿà ÿßŸÑŸÜÿµÿ®
- ŸÉŸÑÿßŸÖ ÿ®ÿ∞Ÿäÿ° ÿ£Ÿà ÿ∫Ÿäÿ± ŸÑÿßÿ¶ŸÇ
- ÿ™ŸáÿØŸäÿØ ÿ£Ÿà ÿ™ÿ≠ÿ±Ÿäÿ∂

ÿßŸÑŸÜÿµ: "${text}"

ÿ£ÿ¨ÿ® ÿ®ŸÄ "ŸÜÿπŸÖ" ÿ•ÿ∞ÿß ŸÉÿßŸÜ Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿ£Ÿä ŸÖŸÜ Ÿáÿ∞Ÿá ÿßŸÑÿ£ŸÖŸàÿ±ÿå ÿ£Ÿà "ŸÑÿß" ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸÖŸÇÿ®ŸàŸÑÿßŸã.
`;
  
  const result = await callGemini(prompt);
  return result.trim().toLowerCase().startsWith("ŸÜÿπŸÖ");
}

function hasExplicitPostReference(text: string): boolean {
  const postKeywords = [
    'ÿßŸÑŸÖŸÜÿ¥Ÿàÿ±', 'ŸÜÿ¥ÿ±ŸÉŸÖ', 'ŸÖÿß ŸÜÿ¥ÿ±ÿ™ŸÖ', 'ŸÜÿ¥ÿ±ÿ™ŸÉŸÖ', 
    'ÿßŸÑŸÖŸÇÿßŸÑ', 'ŸÖÿß ŸÉÿ™ÿ®ÿ™ŸÖ', 'ÿßŸÑÿ®Ÿàÿ≥ÿ™', 'ÿßŸÑŸÖŸÉÿ™Ÿàÿ®'
  ];
  return postKeywords.some(keyword => text.includes(keyword));
}

// ====== Facebook API Functions ======
async function getPageInfo(): Promise<{ name: string; id: string; phone?: string }> {
  try {
    const response = await fetch(
      `${FACEBOOK_GRAPH_URL}/me?fields=name,id,phone&access_token=${PAGE_ACCESS_TOKEN}`
    );
    const data = await response.json();
    return {
      name: data.name || "ÿµŸÅÿ≠ÿ™ŸÜÿß",
      id: data.id || "",
      phone: data.phone || ""
    };
  } catch (error) {
    console.error('Error getting page info:', error);
    return { name: "ÿµŸÅÿ≠ÿ™ŸÜÿß", id: "" };
  }
}

async function getPostDetails(postId: string): Promise<{ message?: string; imageUrl?: string }> {
  try {
    // Get post text and image
    const response = await fetch(
      `${FACEBOOK_GRAPH_URL}/${postId}?fields=message,full_picture,attachments{media}&access_token=${PAGE_ACCESS_TOKEN}`
    );
    const data = await response.json();
    
    let imageUrl = null;
    
    // Try to get image from full_picture
    if (data.full_picture && !data.full_picture.includes("fb_icon_325x325")) {
      imageUrl = data.full_picture;
    }
    
    // Try to get image from attachments
    if (!imageUrl && data.attachments?.data?.[0]?.media?.image?.src) {
      imageUrl = data.attachments.data[0].media.image.src;
    }
    
    return {
      message: data.message || "",
      imageUrl: imageUrl || undefined
    };
  } catch (error) {
    console.error('Error getting post details:', error);
    return { message: "" };
  }
}

async function getLastPost(): Promise<string> {
  try {
    const response = await fetch(
      `${FACEBOOK_GRAPH_URL}/me/posts?limit=1&fields=message&access_token=${PAGE_ACCESS_TOKEN}`
    );
    const data = await response.json();
    return data.data?.[0]?.message || "";
  } catch (error) {
    console.error('Error getting last post:', error);
    return "";
  }
}

async function hideComment(commentId: string): Promise<void> {
  try {
    await fetch(
      `${FACEBOOK_GRAPH_URL}/${commentId}/?is_hidden=true&access_token=${PAGE_ACCESS_TOKEN}`,
      { method: "POST" }
    );
    console.log(`Hidden comment: ${commentId}`);
  } catch (error) {
    console.error('Error hiding comment:', error);
  }
}

async function replyToComment(commentId: string, message: string, attachmentUrl?: string): Promise<void> {
  try {
    const body = new URLSearchParams();
    body.set('message', message);
    body.set('access_token', PAGE_ACCESS_TOKEN);
    
    if (attachmentUrl) {
      // Validate image URL first
      try {
        const imageCheck = await fetch(attachmentUrl, { method: 'HEAD' });
        if (imageCheck.ok) {
          body.set('attachment_url', attachmentUrl);
          console.log('üñºÔ∏è Adding image attachment to reply');
        } else {
          console.log('‚ö†Ô∏è Image URL validation failed, sending text-only');
        }
      } catch (imgError) {
        console.log('‚ö†Ô∏è Image validation error, sending text-only:', imgError);
      }
    }
    
    const response = await fetch(`${FACEBOOK_GRAPH_URL}/${commentId}/comments`, {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: body
    });
    
    const result = await response.json();
    
    // Log detailed response for debugging
    console.log('üìã Facebook API Response Status:', response.status);
    console.log('üìã Facebook API Response:', JSON.stringify(result, null, 2));
    
    if (result.error) {
      console.error('‚ùå Error replying to comment:', result.error);
      console.error('‚ùå Error Code:', result.error.code);
      console.error('‚ùå Error Type:', result.error.type);
      console.error('‚ùå Error Message:', result.error.message);
      
      if (result.error.error_subcode) {
        console.error('‚ùå Error Subcode:', result.error.error_subcode);
      }
      if (result.error.fbtrace_id) {
        console.error('‚ùå FB Trace ID:', result.error.fbtrace_id);
      }
      
      // If image attachment failed, try text-only
      if (attachmentUrl) {
        console.log('üîÑ Retrying without image attachment...');
        const textOnlyBody = new URLSearchParams();
        textOnlyBody.set('message', message);
        textOnlyBody.set('access_token', PAGE_ACCESS_TOKEN);
        
        const retryResponse = await fetch(`${FACEBOOK_GRAPH_URL}/${commentId}/comments`, {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: textOnlyBody
        });
        
        const retryResult = await retryResponse.json();
        console.log('üìã Retry Response Status:', retryResponse.status);
        console.log('üìã Retry Response:', JSON.stringify(retryResult, null, 2));
        
        if (retryResult.error) {
          console.error('‚ùå Retry also failed:', retryResult.error);
          throw new Error(`Facebook API Error: ${retryResult.error.message} (Code: ${retryResult.error.code})`);
        } else {
          console.log('‚úÖ Comment reply sent successfully (text only after retry)');
          console.log('‚úÖ Reply ID:', retryResult.id);
        }
      } else {
        throw new Error(`Facebook API Error: ${result.error.message} (Code: ${result.error.code})`);
      }
    } else {
      const status = attachmentUrl ? 'with image attachment' : 'text only';
      console.log(`‚úÖ Comment reply sent successfully (${status})`);
      console.log('‚úÖ Reply ID:', result.id);
      console.log('‚úÖ Reply URL:', `https://facebook.com/${result.id}`);
    }
    
    console.log(`Replied to comment: ${commentId}`);
  } catch (error) {
    console.error('Error replying to comment:', error);
    throw error;
  }
}

async function sendPrivateMessage(userId: string, messageText: string): Promise<void> {
  try {
    await fetch(`${FACEBOOK_GRAPH_URL}/me/messages?access_token=${PAGE_ACCESS_TOKEN}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        recipient: { id: userId },
        message: { text: messageText }
      })
    });
    
    console.log(`Sent private message to: ${userId}`);
  } catch (error) {
    console.error('Error sending private message:', error);
  }
}

async function sendPrivateCard(userId: string, title: string, subtitle: string, imageUrl?: string): Promise<void> {
  try {
    const element: any = {
      title,
      subtitle
    };
    
    if (imageUrl) {
      element.image_url = imageUrl;
    }
    
    await fetch(`${FACEBOOK_GRAPH_URL}/me/messages?access_token=${PAGE_ACCESS_TOKEN}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        recipient: { id: userId },
        message: {
          attachment: {
            type: "template",
            payload: {
              template_type: "generic",
              elements: [element]
            }
          }
        }
      })
    });
    
    console.log(`Sent private card to: ${userId}`);
  } catch (error) {
    console.error('Error sending private card:', error);
  }
}

// ====== AI Response Generators ======
async function generateCommentReply(comment: string, postText: string): Promise<string> {
  const prompt = `
ÿ£ŸÜÿ™ ŸÖÿ≥ÿßÿπÿØ ÿ∞ŸÉŸä ŸàŸÖÿ±ÿ≠ ŸÑÿµŸÅÿ≠ÿ© ŸÅŸäÿ≥ÿ®ŸàŸÉ. ÿπŸÑŸÇ ÿ£ÿ≠ÿØ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ÿßŸÑÿ™ÿπŸÑŸäŸÇ ÿßŸÑÿ™ÿßŸÑŸä:
"${comment}"

ŸÜÿµ ÿßŸÑŸÖŸÜÿ¥Ÿàÿ± ÿßŸÑÿ£ÿµŸÑŸä:
"${postText}"

ÿßŸÉÿ™ÿ® ÿ±ÿØÿßŸã ŸÖŸáÿ∞ÿ®ÿßŸã ŸàŸàÿØŸäÿßŸã ŸàŸÖÿ±ÿ≠ÿßŸã:
- ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿ•ŸäŸÖŸàÿ¨ŸäŸáÿßÿ™ ŸÖŸÜÿßÿ≥ÿ®ÿ© üòä‚ú®üåü
- ÿßÿ¨ÿπŸÑ ÿßŸÑÿ±ÿØ ŸÇÿµŸäÿ± ŸàŸÖŸÅŸäÿØ (30-60 ŸÉŸÑŸÖÿ©)
- ŸÉŸÜ ÿ•Ÿäÿ¨ÿßÿ®ŸäÿßŸã ŸàŸÖÿ™ŸÅÿßÿπŸÑÿßŸã
- ÿ£ÿ∂ŸÅ Ÿáÿßÿ¥ÿ™ÿßÿ∫ ÿ£Ÿà ÿßÿ´ŸÜŸäŸÜ ŸÖŸÜÿßÿ≥ÿ®ŸäŸÜ
`;
  
  return await callGemini(prompt);
}

async function generatePrivateReply(comment: string): Promise<string> {
  const prompt = `
ÿßŸÉÿ™ÿ® ÿ±ÿ≥ÿßŸÑÿ© ÿÆÿßÿµÿ© ŸÖŸáÿ∞ÿ®ÿ© ŸàŸÖÿ™Ÿàÿ≥ÿ∑ÿ© ÿßŸÑÿ∑ŸàŸÑ (20-50 ŸÉŸÑŸÖÿ©) ŸÑŸÑÿ±ÿØ ÿπŸÑŸâ Ÿáÿ∞ÿß ÿßŸÑÿ™ÿπŸÑŸäŸÇ:
"${comment}"

ÿ¥ÿ¨ÿπ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿπŸÑŸâ ÿßŸÑÿ™ŸÅÿßÿπŸÑ ÿßŸÑÿ•Ÿäÿ¨ÿßÿ®Ÿä ÿ®ÿ∑ÿ±ŸäŸÇÿ© ÿ∫Ÿäÿ± ŸÖÿ®ÿßÿ¥ÿ±ÿ© Ÿàÿßÿ≥ÿ™ÿÆÿØŸÖ ÿ•ŸäŸÖŸàÿ¨ŸäŸáÿßÿ™ ŸÖŸÜÿßÿ≥ÿ®ÿ©.
`;
  
  const fullReply = await callGemini(prompt);
  return fullReply.trim().split(/\s+/).slice(0, 50).join(" ");
}

async function generateOffensiveReply(commentText: string): Promise<string> {
  const prompt = `
ÿ™ŸÖ ÿ™ÿµŸÜŸäŸÅ ÿßŸÑÿ™ÿπŸÑŸäŸÇ ÿßŸÑÿ™ÿßŸÑŸä ÿπŸÑŸâ ÿ£ŸÜŸá ŸÖÿ≥Ÿäÿ° ÿ£Ÿà ÿ∫Ÿäÿ± ŸÖŸÜÿßÿ≥ÿ®:
"${commentText}"

ÿßŸÉÿ™ÿ® ÿ±ÿ≥ÿßŸÑÿ© ÿÆÿßÿµÿ© ŸÖŸáÿ∞ÿ®ÿ© ŸàŸÖÿ™Ÿàÿßÿ≤ŸÜÿ© (20-50 ŸÉŸÑŸÖÿ©) ÿ™Ÿàÿ∂ÿ≠:
- ÿ£ŸÜŸá ÿ™ŸÖ ÿ•ÿÆŸÅÿßÿ° ÿßŸÑÿ™ÿπŸÑŸäŸÇ
- ŸÜÿ±ÿ≠ÿ® ÿ®ÿßŸÑÿ™ÿµÿ≠Ÿäÿ≠ ŸàÿßŸÑÿ™ŸÅÿßÿπŸÑ ÿßŸÑÿ•Ÿäÿ¨ÿßÿ®Ÿä
- ŸÜÿ≠ÿ™ÿ±ŸÖ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ¢ÿ±ÿßÿ° ÿßŸÑŸÖŸáÿ∞ÿ®ÿ©
- ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿ•ŸäŸÖŸàÿ¨ŸäŸáÿßÿ™ ŸÖŸÜÿßÿ≥ÿ®ÿ©

ŸÉŸÜ ŸÖŸáÿ∞ÿ®ÿßŸã ŸàŸàÿØŸàÿØÿßŸã ÿ±ÿ∫ŸÖ ÿßŸÑŸÖŸàŸÇŸÅ.
`;
  
  const fullReply = await callGemini(prompt);
  return fullReply.trim().split(/\s+/).slice(0, 50).join(" ");
}

async function answerImageQuestion(imageUrl: string, question: string): Promise<string> {
  try {
    // Download and convert image to base64
    const imgResponse = await fetch(imageUrl);
    const arrayBuffer = await imgResponse.arrayBuffer();
    const base64Image = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
    
    const prompt = `
ÿ£ŸÜÿ™ ŸÖÿ≥ÿßÿπÿØ ÿ∞ŸÉŸä ŸÖÿ™ÿÆÿµÿµ ŸÅŸä ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿµŸàÿ± ŸàÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿπŸÑŸâ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ©.

ÿ≥ÿ§ÿßŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿπŸÜ ÿßŸÑÿµŸàÿ±ÿ©:
"${question}"

ÿ≠ŸÑŸÑ ÿßŸÑÿµŸàÿ±ÿ© ÿßŸÑŸÖÿ±ŸÅŸÇÿ© Ÿàÿ£ÿ¨ÿ® ÿπŸÑŸâ ÿßŸÑÿ≥ÿ§ÿßŸÑ:
- ÿ•ÿ∞ÿß ÿ≥ÿ£ŸÑ ÿπŸÜ ŸÜÿµ ŸÅŸä ÿßŸÑÿµŸàÿ±ÿ©ÿå ÿßŸÇÿ±ÿ£Ÿá ÿ®ÿØŸÇÿ©
- ÿ•ÿ∞ÿß ÿ≥ÿ£ŸÑ ÿπŸÜ ÿßŸÑÿ£ŸÑŸàÿßŸÜÿå ÿ≠ÿØÿØŸáÿß ÿ®Ÿàÿ∂Ÿàÿ≠
- ÿ•ÿ∞ÿß ÿ≥ÿ£ŸÑ ÿπŸÜ ÿßŸÑÿπŸÜÿßÿµÿ±ÿå ÿµŸÅŸáÿß ÿ®ÿßŸÑÿ™ŸÅÿµŸäŸÑ
- ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿ•ŸäŸÖŸàÿ¨ŸäŸáÿßÿ™ ŸÖŸÜÿßÿ≥ÿ®ÿ© üì∑‚ú®üé®
- ÿßÿ¨ÿπŸÑ ÿßŸÑÿ±ÿØ Ÿàÿßÿ∂ÿ≠ ŸàŸÖŸÅŸäÿØ (50-100 ŸÉŸÑŸÖÿ©)
`;
    
    return await callGemini(prompt, {
      mimeType: "image/jpeg",
      data: base64Image
    });
  } catch (error) {
    console.error('Error analyzing image:', error);
    return "‚ùì ÿπÿ∞ÿ±ÿßŸãÿå ŸÑŸÖ ÿ£ÿ™ŸÖŸÉŸÜ ŸÖŸÜ ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿµŸàÿ±ÿ© ÿ≠ÿßŸÑŸäÿßŸã. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.";
  }
}

// ====== Main Handler Functions ======
async function handleCommentEvent(change: any): Promise<void> {
  const commentId = change.value?.comment_id;
  const commentText = change.value?.message || change.value?.comment || "";
  const postId = change.value?.post_id;
  const fromId = change.value?.from?.id;
  
  if (!commentId || !commentText || !fromId) {
    console.log('Missing required comment data');
    return;
  }
  
  // Get page info
  const pageInfo = await getPageInfo();
  
  // Skip if comment is from the page itself
  if (fromId === pageInfo.id) {
    console.log('Skipping comment from page itself');
    return;
  }
  
  console.log(`Processing comment: ${commentText}`);
  
  // Get post details
  const postDetails = await getPostDetails(postId);
  const defaultImageUrl = "https://www.facebook.com/images/fb_icon_325x325.png";
  
  // Check for offensive content
  if (await isOffensiveContent(commentText)) {
    console.log('Offensive content detected, hiding comment');
    
    await hideComment(commentId);
    
    // Send private notification about hidden comment
    await sendPrivateCard(
      fromId,
      "üì© ŸàÿµŸÑŸÜÿß ÿ™ÿπŸÑŸäŸÇŸÉ",
      `üí¨ "${commentText.substring(0, 50)}..."`,
      postDetails.imageUrl || defaultImageUrl
    );
    
    const offensiveReply = await generateOffensiveReply(commentText);
    await sendPrivateMessage(fromId, offensiveReply);
    
    // Add contact button if phone available
    if (pageInfo.phone) {
      await sendPrivateMessage(fromId, `üìû ŸÑŸÑÿ™ŸàÿßÿµŸÑ ÿßŸÑŸÖÿ®ÿßÿ¥ÿ±: ${pageInfo.phone}`);
    }
    
    return;
  }
  
  // Handle image questions
  if (isImageQuestion(commentText) && postDetails.imageUrl) {
    console.log('Image question detected');
    
    const imageAnswer = await answerImageQuestion(postDetails.imageUrl, commentText);
    await replyToComment(commentId, imageAnswer, postDetails.imageUrl);
    
    await sendPrivateCard(
      fromId,
      "üì∑ ÿ•ÿ¨ÿßÿ®ÿ© ÿπŸÜ ÿ≥ÿ§ÿßŸÑŸÉ ÿ≠ŸàŸÑ ÿßŸÑÿµŸàÿ±ÿ©",
      `üí¨ "${commentText.substring(0, 50)}..."`,
      postDetails.imageUrl
    );
    
    return;
  }
  
  // Handle regular comments
  const reply = await generateCommentReply(commentText, postDetails.message || "");
  await replyToComment(commentId, reply);
  
  // Send private thank you
  await sendPrivateCard(
    fromId,
    "‚ù§Ô∏è ÿ¥ŸÉÿ±ÿßŸã ŸÑÿ™ÿπŸÑŸäŸÇŸÉ",
    `üí¨ "${commentText.substring(0, 50)}..."`,
    postDetails.imageUrl || defaultImageUrl
  );
  
  const privateReply = await generatePrivateReply(commentText);
  await sendPrivateMessage(fromId, privateReply);
}

async function handleMessageEvent(msg: any): Promise<void> {
  const senderId = msg.sender?.id;
  const messageText = msg.message?.text;
  
  if (!senderId || !messageText) {
    console.log('Missing required message data');
    return;
  }
  
  console.log(`Processing message: ${messageText}`);
  
  // Skip offensive messages
  if (await isOffensiveContent(messageText)) {
    console.log('Offensive message detected, skipping');
    return;
  }
  
  // Get page info and last post
  const pageInfo = await getPageInfo();
  const lastPost = await getLastPost();
  
  // Generate smart reply
  const isAboutPost = hasExplicitPostReference(messageText);
  
  const prompt = isAboutPost
    ? `
ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ© ÿ™ÿ™ÿπŸÑŸÇ ÿ®ŸÖŸÜÿ¥Ÿàÿ±:
"${messageText}"

ÿßŸÉÿ™ÿ® ÿ±ÿØÿßŸã ŸÖŸáÿ∞ÿ®ÿßŸã ŸàŸÖÿÆÿ™ÿµÿ±ÿßŸã ŸÖÿπ ÿ•ŸäŸÖŸàÿ¨ŸäŸáÿßÿ™ÿå ŸÖÿ≥ÿ™ŸÜÿØÿßŸã ÿ•ŸÑŸâ ÿßŸÑŸÖŸÜÿ¥Ÿàÿ± ÿßŸÑÿ™ÿßŸÑŸä:
"${lastPost}"

ÿßÿ¨ÿπŸÑ ÿßŸÑÿ±ÿØ ŸÖŸÅŸäÿØ ŸàŸàÿØŸàÿØ (30-80 ŸÉŸÑŸÖÿ©).
`
    : `
ÿßŸÉÿ™ÿ® ÿ±ÿØÿßŸã ŸÖŸáÿ∞ÿ®ÿßŸã ŸàŸÖÿÆÿ™ÿµÿ±ÿßŸã ŸÖÿπ ÿ•ŸäŸÖŸàÿ¨ŸäŸáÿßÿ™ ÿπŸÑŸâ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ©:
"${messageText}"

ÿßÿ≥ŸÖ ÿßŸÑÿµŸÅÿ≠ÿ© ŸáŸà "${pageInfo.name}"
ÿßÿ¨ÿπŸÑ ÿßŸÑÿ±ÿØ ŸàÿØŸàÿØ ŸàŸÖŸÅŸäÿØ (30-80 ŸÉŸÑŸÖÿ©).
`;
  
  const smartReply = await callGemini(prompt);
  await sendPrivateMessage(senderId, smartReply);
}

// ====== Main Server Handler ======
serve(async (req) => {
  console.log(`üöÄ Facebook Webhook v2 called: ${req.method} ${req.url}`);
  
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }
  
  const url = new URL(req.url);
  
  try {
    // Handle Facebook webhook verification (GET request)
    if (req.method === 'GET') {
      const mode = url.searchParams.get('hub.mode');
      const token = url.searchParams.get('hub.verify_token');
      const challenge = url.searchParams.get('hub.challenge');
      
      if (mode === 'subscribe' && token === VERIFY_TOKEN) {
        console.log('‚úÖ Webhook verified successfully');
        return new Response(challenge, { status: 200, headers: corsHeaders });
      }
      
      console.log('‚ùå Webhook verification failed');
      return new Response('Forbidden', { status: 403, headers: corsHeaders });
    }
    
    // Handle webhook events (POST request)
    if (req.method === 'POST') {
      const body = await req.json();
      console.log('üì© Received webhook data:', JSON.stringify(body, null, 2));
      
      // Process entries
      for (const entry of body.entry || []) {
        // Handle feed changes (comments)
        for (const change of entry.changes || []) {
          if (change.field === 'feed' && change.value?.comment_id && change.value.verb === 'add') {
            await handleCommentEvent(change);
          }
        }
        
        // Handle messages
        for (const msg of entry.messaging || []) {
          if (msg.message?.text) {
            await handleMessageEvent(msg);
          }
        }
      }
      
      return new Response('‚úÖ Event received and processed', { 
        status: 200, 
        headers: corsHeaders 
      });
    }
    
    return new Response('Method Not Allowed', { 
      status: 405, 
      headers: corsHeaders 
    });
    
  } catch (error) {
    console.error('‚ùå Webhook error:', error);
    return new Response(JSON.stringify({ error: error.message }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});